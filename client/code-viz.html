<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>CodeSteward MRI v6 (Final Density Fix)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: "Segoe UI", sans-serif;
            background: #121212;
            color: #ccc;
            display: flex;
            height: 100vh;
        }

        /* LAYOUT & CONTAINERS */
        #drop-zone {
            position: fixed;
            inset: 0;
            background: #121212;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            border: 4px dashed #333;
        }

        #drop-zone.hidden {
            display: none;
        }

        #viz-panel {
            flex: 1;
            position: relative;
            background: #121212;
        }

        #sidebar {
            width: 350px;
            background: #1e1e1e;
            border-left: 1px solid #333;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        /* SIDEBAR STYLES */
        .tree-header {
            padding: 10px;
            border-bottom: 1px solid #333;
            font-weight: bold;
            background: #252526;
        }

        .tree-node {
            padding: 2px 8px;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            cursor: pointer;
            display: flex;
            align-items: center;
            color: #aaa;
        }

        .tree-node:hover {
            background: #2a2d2e;
            color: #fff;
        }

        .tree-node.highlighted {
            background: #094771;
            color: #fff;
        }

        .dot {
            width: 8px;
            height: 8px;
            margin-left: auto;
            border-radius: 50%;
        }

        /* TOOLTIP */
        #tooltip {
            position: absolute;
            background: #1e1e1e;
            padding: 10px;
            border: 1px solid #555;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
            color: #fff;
            box-shadow: 0 4px 10px #000;
        }

        /* VISUAL HACK: Sharper edges, reduced sub-pixel artifacts */
        svg {
            shape-rendering: crispEdges;
        }
    </style>
</head>

<body>
    <div id="drop-zone">
        <h1>Drop 'codebase_mri.json'</h1>
        <p>v6: Binary Tiling for 100% Space Utilization.</p>
    </div>
    <div style="display:flex; width:100%; height:100%">
        <div id="viz-panel"></div>
        <div id="sidebar">
            <div class="tree-header">Explorer</div>
            <div id="tree-content"></div>
        </div>
    </div>
    <div id="tooltip"></div>

    <script>
        const colorScale = d3.scaleLinear().domain([0, 10, 50]).range(["#569cd6", "#dcdcaa", "#ce9178"]).clamp(true);
        const TILING_ALGORITHM = d3.treemapBinary; // <-- NEW: Use Binary Tiling to fill 100% space.

        function logDebug(data) {
            console.group("ðŸ” MRI Debug Logs (v6)");
            console.log("Tiling Algorithm:", TILING_ALGORITHM === d3.treemapBinary ? "d3.treemapBinary (Max Density)" : "d3.treemapSquarify (Default)");
            console.log("Total Nodes (after filter):", data.descendants().length);
            console.log("Total LOC rendered:", data.value);
            console.groupEnd();
        }

        function init(rawData) {
            // 1. FILTER: Aggressively remove nodes that are only noise
            const filteredData = filterNoise(rawData);

            // 2. HIERARCHY: Create D3 structure
            const root = d3.hierarchy(filteredData)
                .sum(d => d.metrics ? d.metrics.loc : 0)
                .sort((a, b) => b.value - a.value);

            logDebug(root);
            renderTreemap(root);
            renderSidebar(root);
            document.getElementById('drop-zone').classList.add('hidden');
        }

        function filterNoise(node) {
            if (!node.children) return node;

            // Aggressively remove very small functions/code fragments that cause visual noise
            node.children = node.children.filter(child => {
                const isNoiseFile = ['lock', 'png', 'svg'].some(x => child.name.includes(x));
                const isTinyFunction = child.type !== 'folder' && child.metrics.loc < 5;
                return !isNoiseFile && !isTinyFunction;
            });

            // Recurse on filtered children
            node.children.forEach(filterNoise);

            // Recalculate metrics for parents after filtering
            node.metrics.loc = node.children.reduce((acc, c) => acc + c.metrics.loc, node.type === 'file' && node.children.length === 0 ? node.metrics.loc : 0);

            return node;
        }

        function renderTreemap(root) {
            const w = document.getElementById('viz-panel').clientWidth;
            const h = document.getElementById('viz-panel').clientHeight;

            // *** CORE FIX: Use Binary Tiling for 100% density ***
            d3.treemap()
                .size([w, h])
                .paddingInner(0)
                .paddingOuter(0)
                .round(false)
                .tile(TILING_ALGORITHM) // <--- Applying the binary algorithm
                (root);

            const svg = d3.select("#viz-panel").html("").append("svg").attr("width", w).attr("height", h);

            // 1. Draw Folder Backgrounds (The "Container" for Structure)
            svg.selectAll("rect.folder")
                .data(root.descendants().filter(d => d.depth > 0 && d.children))
                .join("rect")
                .attr("x", d => d.x0).attr("y", d => d.y0)
                .attr("width", d => d.x1 - d.x0).attr("height", d => d.y1 - d.y0)
                .attr("fill", "#1e1e1e")
                .attr("stroke", "#2d2d2d").attr("stroke-width", 0.5);

            // 2. Draw Leaves (Files/Functions)
            svg.selectAll("rect.leaf")
                .data(root.leaves())
                .join("rect")
                .attr("x", d => d.x0).attr("y", d => d.y0)
                .attr("width", d => d.x1 - d.x0).attr("height", d => d.y1 - d.y0)
                // Use a neutral grey for the (misc/imports) sections
                .attr("fill", d => d.data.name === '(misc/imports)' ? '#444' : colorScale(d.data.metrics.complexity))
                // Only draw a tiny stroke if the box is big enough to prevent smudge
                .attr("stroke", d => (d.x1 - d.x0) > 10 ? "#121212" : "none")
                .attr("stroke-width", 0.5)
                .on("mouseover", (e, d) => showTooltip(e, d))
                .on("mouseout", hideTooltip);

            // Text labels for large nodes
            svg.selectAll("text.label")
                .data(root.leaves().filter(d => (d.x1 - d.x0) > 40 && (d.y1 - d.y0) > 15))
                .join("text")
                .attr("x", d => d.x0 + 5)
                .attr("y", d => d.y0 + 15)
                .text(d => d.data.name)
                .attr("font-size", "10px")
                .attr("fill", "rgba(255,255,255,0.9)");
        }

        function renderSidebar(root) {
            const html = buildTree(root.data, 0);
            document.getElementById('tree-content').innerHTML = html;
        }

        function buildTree(node, depth) {
            if (!node) return '';

            if (node.type !== 'folder' && node.metrics.loc < 10) return '';

            let icon = node.type === 'folder' ? 'ðŸ“' : (node.name === '(misc/imports)' ? 'âš™ï¸' : 'ðŸ“„');
            let color = colorScale(node.metrics.complexity);
            if (node.name === '(misc/imports)') color = '#444';

            let html = `<div class="tree-node" style="padding-left:${depth * 12}px">
                <span style="opacity:0.7;margin-right:5px">${icon}</span>
                <span style="flex:1">${node.name}</span>
                <span style="font-family:monospace;font-size:10px;opacity:0.5">${node.metrics.loc}</span>
                <span class="dot" style="background:${color}"></span>
            </div>`;
            if (node.children) node.children.forEach(c => html += buildTree(c, depth + 1));
            return html;
        }

        function showTooltip(e, d) {
            const t = document.getElementById('tooltip');
            t.style.opacity = 1; t.style.left = e.pageX + 10 + "px"; t.style.top = e.pageY + 10 + "px";
            t.innerHTML = `<strong>${d.data.name}</strong><br>LOC: ${d.value}<br>Complexity: ${d.data.metrics.complexity}`;
        }
        function hideTooltip() { document.getElementById('tooltip').style.opacity = 0; }

        // Drag Drop Boilerplate
        window.ondragover = e => e.preventDefault();
        window.ondrop = e => { e.preventDefault(); const fr = new FileReader(); fr.onload = x => init(JSON.parse(x.target.result)); fr.readAsText(e.dataTransfer.files[0]); };
    </script>
</body>

</html>